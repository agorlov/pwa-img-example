# Демонстрация офлайн-загрузки в PWA

Это демонстрационное приложение, которое показывает возможность офлайн-загрузки файлов с использованием технологий Progressive Web App (PWA). Файлы, выбранные в режиме офлайн, помещаются в очередь и автоматически синхронизируются при восстановлении сетевого подключения.

Приложение создано на чистом JavaScript, HTML, CSS и простом бэкенде на PHP.

### Возможности

-   **Offline First:** Оболочка приложения кэшируется и загружается даже без подключения к сети.
-   **Очередь файлов:** Файлы, выбранные в офлайн-режиме, сохраняются локально с помощью IndexedDB.
-   **Фоновая синхронизация:** Использует Background Sync API для автоматической загрузки файлов из очереди, когда появляется сеть.
-   **Превью изображений:** Показывает превью для изображений, находящихся в очереди на загрузку.
-   **Обновление статуса:** Пользовательский интерфейс в реальном времени обновляет статус сети и загрузки файлов.

### Как запустить

1.  **Требования:** У вас должен быть установлен `php`.
2.  **Клонируйте репозиторий** (если применимо).
3.  **Перейдите в директорию проекта.**
4.  **Запустите локальный PHP-сервер:**
    ```bash
    php -S localhost:8000
    ```
5.  **Откройте браузер** и перейдите по адресу `http://localhost:8000`.

### Как протестировать офлайн-режим

1.  Откройте приложение в браузере (например, Chrome или Firefox).
2.  Откройте Инструменты разработчика (F12).
3.  Перейдите на вкладку **"Network"** (Сеть).
4.  Найдите выпадающий список (обычно там "No throttling") и выберите **"Offline"**.
5.  Попробуйте загрузить файл. Он будет добавлен в список "В очереди на отправку".
6.  Переключите сеть обратно на "No throttling". Файл будет автоматически загружен, а списки в интерфейсе обновятся.

---

# Теория: Реализация офлайн-загрузки файлов в PWA с последующей синхронизацией

Это одна из ключевых и мощных возможностей PWA (Progressive Web App). Реализация офлайн-загрузки с последующей синхронизацией — классическая задача для этой технологии.

### Концепция

1.  **Пользователь в офлайн-режиме:** Пользователь нажимает кнопку "Загрузить файл/изображение".
2.  **Перехват:** PWA-приложение определяет, что подключения к сети нет.
3.  **Локальное сохранение:** Вместо того чтобы выдать ошибку, приложение сохраняет этот файл (или его данные) во внутреннем хранилище браузера. Вместе с файлом сохраняется и "намерение" — метаданные о том, на какой серверный адрес (endpoint) его нужно было отправить.
4.  **Ожидание:** Приложение регистрирует задачу для фоновой синхронизации.
5.  **Восстановление сети:** Как только устройство снова подключается к интернету, операционная система "пробуждает" приложение в фоновом режиме.
6.  **Синхронизация:** Приложение достает сохраненный файл из хранилища и отправляет его на сервер, завершая изначальный запрос. С точки зрения пользователя, все просто "сработало", когда появилась сеть.

### Ключевые технологии (Web API)

Для реализации этого механизма используются три основных технологии:

1.  **Service Worker:** Это скрипт, который браузер запускает в фоновом режиме, отдельно от веб-страницы. Он действует как прокси-сервер между вашим приложением, браузером и сетью. Именно Service Worker перехватывает исходящие запросы (`fetch` event).

2.  **IndexedDB:** Это полноценная NoSQL база данных, встроенная в браузер. Она идеально подходит для хранения больших объемов данных, включая бинарные данные файлов (`Blob`). `localStorage` для этого не подходит из-за малого лимита и работы только со строками. В IndexedDB вы создаете хранилище, куда помещаете сам файл и информацию для его отправки.

3.  **Background Sync API:** Это специальный API, который позволяет отложить какое-либо действие (в нашем случае — отправку данных) до момента восстановления стабильного интернет-соединения.
    *   Вы регистрируете тег синхронизации (например, `'upload-queue'`).
    *   Когда Service Worker получает событие `sync` с этим тегом, он выполняет код, который вы написали для отправки данных из IndexedDB.

### Упрощенная схема логики

```javascript
// 1. В коде вашей страницы (клиент)
uploadButton.addEventListener('click', async () => {
  const file = fileInput.files[0];

  if ('serviceWorker' in navigator && 'SyncManager' in window) {
    // Если есть поддержка PWA и Background Sync
    const sw = await navigator.serviceWorker.ready;
    // Сохраняем файл в IndexedDB и просим SW о синхронизации
    saveFileToIndexedDB(file);
    sw.sync.register('upload-queue'); // Регистрируем задачу
  } else {
    // Фоллбэк для старых браузеров - просто пытаемся отправить
    try {
      await fetch('/api/upload', { method: 'POST', body: file });
    } catch (err) {
      alert("Ошибка отправки. Проверьте подключение.");
    }
  }
});

// 2. В файле Service Worker (service-worker.js)
self.addEventListener('sync', event => {
  if (event.tag === 'upload-queue') {
    // Когда пришло событие sync, выполняем отложенную отправку
    event.waitUntil(sendQueueFromIndexedDB());
  }
});

async function sendQueueFromIndexedDB() {
  const files = await getFilesFromIndexedDB();
  for (const file of files) {
    await fetch('/api/upload', { method: 'POST', body: file.data });
    // Если успешно - удаляем из очереди в IndexedDB
    await deleteFileFromIndexedDB(file.id);
  }
}
```

**Итог:** Это не просто возможно, а является одним из главных преимуществ PWA, создавая бесшовный и надежный пользовательский опыт, не уступающий нативным приложениям.
