# Реализация офлайн-загрузки файлов в PWA с последующей синхронизацией

Это одна из ключевых и мощных возможностей PWA (Progressive Web App). Реализация офлайн-загрузки с последующей синхронизацией — классическая задача для этой технологии.

### Концепция

1.  **Пользователь в офлайн-режиме:** Пользователь нажимает кнопку "Загрузить файл/изображение".
2.  **Перехват:** PWA-приложение определяет, что подключения к сети нет.
3.  **Локальное сохранение:** Вместо того чтобы выдать ошибку, приложение сохраняет этот файл (или его данные) во внутреннем хранилище браузера. Вместе с файлом сохраняется и "намерение" — метаданные о том, на какой серверный адрес (endpoint) его нужно было отправить.
4.  **Ожидание:** Приложение регистрирует задачу для фоновой синхронизации.
5.  **Восстановление сети:** Как только устройство снова подключается к интернету, операционная система "пробуждает" приложение в фоновом режиме.
6.  **Синхронизация:** Приложение достает сохраненный файл из хранилища и отправляет его на сервер, завершая изначальный запрос. С точки зрения пользователя, все просто "сработало", когда появилась сеть.

### Ключевые технологии (Web API)

Для реализации этого механизма используются три основных технологии:

1.  **Service Worker:** Это скрипт, который браузер запускает в фоновом режиме, отдельно от веб-страницы. Он действует как прокси-сервер между вашим приложением, браузером и сетью. Именно Service Worker перехватывает исходящие запросы (`fetch` event).

2.  **IndexedDB:** Это полноценная NoSQL база данных, встроенная в браузер. Она идеально подходит для хранения больших объемов данных, включая бинарные данные файлов (`Blob`). `localStorage` для этого не подходит из-за малого лимита и работы только со строками. В IndexedDB вы создаете хранилище, куда помещаете сам файл и информацию для его отправки.

3.  **Background Sync API:** Это специальный API, который позволяет отложить какое-либо действие (в нашем случае — отправку данных) до момента восстановления стабильного интернет-соединения.
    *   Вы регистрируете тег синхронизации (например, `'upload-queue'`).
    *   Когда Service Worker получает событие `sync` с этим тегом, он выполняет код, который вы написали для отправки данных из IndexedDB.

### Упрощенная схема логики

```javascript
// 1. В коде вашей стра��ицы (клиент)
uploadButton.addEventListener('click', async () => {
  const file = fileInput.files[0];

  if ('serviceWorker' in navigator && 'SyncManager' in window) {
    // Если есть поддержка PWA и Background Sync
    const sw = await navigator.serviceWorker.ready;
    // Сохраняем файл в IndexedDB и просим SW о синхронизации
    saveFileToIndexedDB(file);
    sw.sync.register('upload-queue'); // Регистрируем задачу
  } else {
    // Фоллбэк для старых браузеров - просто пытаемся отправить
    try {
      await fetch('/api/upload', { method: 'POST', body: file });
    } catch (err) {
      alert("Ошибка отправки. Проверьте подключение.");
    }
  }
});

// 2. В файле Service Worker (service-worker.js)
self.addEventListener('sync', event => {
  if (event.tag === 'upload-queue') {
    // Когда пришло событие sync, выполняем отложенную отправку
    event.waitUntil(sendQueueFromIndexedDB());
  }
});

async function sendQueueFromIndexedDB() {
  const files = await getFilesFromIndexedDB();
  for (const file of files) {
    await fetch('/api/upload', { method: 'POST', body: file.data });
    // Если успешно - удаляем из очереди в IndexedDB
    await deleteFileFromIndexedDB(file.id);
  }
}
```

**Итог:** Это не просто возможно, а является одним из главных преимуществ PWA, создавая бесшовный и надежный пользовательский опыт, не уступающий нативным приложениям.
